import script_bash
import script_briteonyx

from throw_out_your_templates_3_core_visitor_map import VisitorMap


class Script(script_briteonyx.Script):
    def __init__(self):
        script_briteonyx.Script.__init__(self)

    def generate(self):
        self.add_source_header()
        self.note('Assumes this project has been activated using the BriteOnyx framework.')
        self.note("We MUST NOT EVER 'exit' during BriteOnyx bootstrap or activation")
        self.rule()
        self.note('Uncomment the following two lines for debugging')
        self.comment('set -o verbose')
        self.comment('set -o xtrace')
        self.someday('Add inverse commands to isolate debugging')
        self.line()
        self.rule()
        self.comment('Declare needed functionality to support the BriteOnyx framework')
        self.note("We use the 'bo' prefix by convention for all our BriteOnyx support functions.")
        self.line()
        self.rule()
        self.comment('Functions in this section should NOT call functions from following sections')
        self.line()
        self.line('boLog () {')
        self.line('  # Log the message $1 to STDERR')
        self.line('  # NOTE:  Should only be called from this script')
        self.line('  # $1 = message')
        self.line('  echo -e "$1" >&2')
        self.line('} && export -f boLog')
        self.line()
        self.line('boNodeCanonical () {')
        self.line('  # Return the canonical pathname for file system node $1')
        self.line('  # NOTE: Must be called via command substitution, e.g.:')
        self.line('''  #   "$(boNodeCanonical '$1')"''')
        self.line('  [[ $# -eq 1 ]] || return 100')
        self.line('  # $1 = pathname of file system node')
        self.line('  declare Result')
        self.line('  # NOTE: This call to "readlink" is not supported on Apple Mac OS X, so deal with it...')
        self.line('  Result="$(readlink -m $1)"')
        self.line('  [[ $? -eq 0   ]] && echo "$Result" && return 0')
        self.line('  [[ "$1" = "." ]] && echo "$PWD"       && return 0')
        self.line('  echo "$1"')
        self.line('} && export -f boNodeCanonical')
        self.line()
        self.line('boTrace () {')
        self.line('  # Trace message $1')
        self.line('  # $1 = message')
        self.line('  [[ -n "$BO_Trace" ]] && boLog "TRACE: $1"')
        self.line('} && export -f boTrace')
        self.line()
        self.line('boTraceEntry () {')
        self.line('  # Trace the entry of execution into caller with source location name $1 and line $2 called with')
        self.line('  #   argument count $3 and arguments $4')
        self.line('  [[ $# -eq 4 ]] || return 100')
        self.line('  # $1 = caller source location name ($FUNCNAME or $0)')
        self.line('  # $2 = caller source location line ($LINENO)')
        self.line('  # $3 = caller argument count ($#)')
        self.line('  # $4 = caller arguments ($*)')
        self.line('''  boTrace "'$1:$2' called with $3 args: '$4'"''')
        self.line('} && export -f boTraceEntry')
        self.line()
        self.line('boTraceValue () {')
        self.line('  # Trace value $2 described as $1')
        self.line('  [[ $# -eq 2 ]] || return 100')
        self.line('  # $1 = description of value')
        self.line('  # $2 = value')
        self.line('''  boTrace "$1 = '$2'"''')
        self.line('} && export -f boTraceValue')
        self.line()
        self.line('boTraceVariable () {')
        self.line('  # Trace environment variable $1')
        self.line('  [[ $# -eq 1 ]] || return 100')
        self.line('  # $1 = name of environment variable')
        self.line('  declare -r Name="$1"')
        self.line('  declare -r Value="${!Name}"')
        self.line('''  boTraceValue "Variable '$Name'" "$Value"''')
        self.line('} && export -f boTraceVariable')
        self.line()
        self.rule()
        self.comment('Functions in this section should NOT call functions from following sections')
        self.line()
        self.line('boDirectoryExists () {')
        self.line('  boNodeIsDirectory "$1"')
        self.line('} && export -f boDirectoryExists')
        self.line()
        self.line('boFileExists () {')
        self.line('  boNodeIsFile "$1"')
        self.line('} && export -f boFileExists')
        self.line()
        self.line('boNodeExists () {')
        self.line('  # Return whether node $1 exists')
        self.line('  [[ $# -eq 1 ]] || return 100')
        self.line('  # $1 = node pathname')
        self.line('  [[ -e "$1" ]]')
        self.line('} && export -f boNodeExists')
        self.line()
        self.line('boNodeIsDirectory () {')
        self.line('  # Return whether node $1 is a directory')
        self.line('  [[ $# -eq 1 ]] || return 100')
        self.line('  # $1 = node pathname')
        self.line('  [[ -d "$1" ]]')
        self.line('} && export -f boNodeIsDirectory')
        self.line()
        self.line('boNodeIsFile () {')
        self.line('  # Return whether node $1 is a file')
        self.line('  [[ $# -eq 1 ]] || return 100')
        self.line('  # $1 = node pathname')
        self.line('  [[ -f "$1" ]]')
        self.line('} && export -f boNodeIsFile')
        self.line()
        self.line('boVariableIsMissing () {')
        self.line('  # Return whether environment variable $1 is missing (undefined or empty)')
        self.line('  [[ $# -eq 1 ]] || return 100')
        self.line('  # $1 = name of environment variable')
        self.line('  declare -r Name="$1"')
        self.line('  declare -r Value="${!Name}"')
        self.line('  [[ -z "$Value" ]]')
        self.line('} && export -f boVariableIsMissing')
        self.line()
        self.rule()
        self.comment('Functions in this section should NOT call functions from following sections')
        self.line()
        self.line('boLogDebug () {')
        self.line('  boLog "DEBUG: $1"')
        self.line('} && export -f boLogDebug')
        self.line()
        self.line('boLogError () {')
        self.line('  boLog "ERROR: $1"')
        self.line('} && export -f boLogError')
        self.line()
        self.line('boLogFatal () {')
        self.line('  boLog "FATAL: $1"')
        self.line('} && export -f boLogFatal')
        self.line()
        self.line('boLogInfo () {')
        self.line('  boLog "INFO:  $1"')
        self.line('} && export -f boLogInfo')
        self.line()
        self.line('boLogWarn () {')
        self.line('  boLog "WARN:  $1"')
        self.line('} && export -f boLogWarn')
        self.line()
        self.rule()
        self.comment('Functions in this section should NOT call functions from following sections')
        self.line()
        self.line('boAbort () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('''  # Abort execution due to previous command's status $3 while reporting fatal log message $5''')
        self.line('  #   (including source location name $1 and line $2) and propagating outgoing status code $4')
        self.line('  # TODO: Rename to boFail?')
        self.line('  [[ $# -eq 5 ]] || return 100')
        self.line('  # $1 = caller source location name ($FUNCNAME or $0)')
        self.line('  # $2 = caller source location line ($LINENO)')
        self.line('  # $3 = incoming status code from previous command ($?, non-zero)')
        self.line('  # $4 = outgoing status code (repeat $? unless overriding)')
        self.line('  # $5 = message')
        self.line('  [[ "$3" -eq 0 ]] && return 100')
        self.line('''  boLogFatal "ABORT: Status $3 at '$1:$2' -> status $4: $5"''')
        self.line('  return "$4"')
        self.line('} && export -f boAbort')
        self.line()
        self.line('boFailed () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('''  # Log failed execution due to previous command's status $3 as reported at source location name''')
        self.line('  #   $1 and line $2, then propagate the failed status')
        self.line('  [[ $# -eq 3 ]] || return 100')
        self.line('  # $1 = caller source location name ($FUNCNAME or $0)')
        self.line('  # $2 = caller source location line ($LINENO)')
        self.line('  # $3 = incoming status code from previous command ($?, non-zero)')
        self.line('  [[ "$3" -eq 0 ]] && return 100')
        self.line('''  boLogFatal "FAILED: Status $3 at '$1:$2'"''')
        self.line('  return "$3"')
        self.line('} && export -f boFailed')
        self.line()
        self.rule()
        self.comment('Functions in this section should NOT call functions from following sections')
        self.line()
        self.line('boArgsRequire () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('  # Require that the actual argument count $3 equal the expected argument count $4 in the caller')
        self.line('  #   with source location name $1 and line $2')
        self.line('  [[ $# -eq 4 ]] || return 100')
        self.line('  # $1 = caller source location name ($FUNCNAME or $0)')
        self.line('  # $2 = caller source location line ($LINENO)')
        self.line('  # $3 = actual argument count ($#)')
        self.line('  # $4 = expected argument count')
        self.line('  declare -r Msg="Expected $4 arguments but got $3!"')
        self.line('  [[ $3 -eq $4 ]] || boAbort "$1" "$2" $? 100 "$Msg" || return $?')
        self.line('} && export -f boArgsRequire')
        self.line()
        self.rule()
        self.comment('Functions in this section should NOT call functions from following sections')
        self.line()
        self.line('boDirectoryCreate () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('  # Create directory $1, if it does not already exist')
        self.line('  boArgsRequire "$FUNCNAME" "$LINENO" $# 1 || return $?')
        self.line('  # $1 = directory pathname')
        self.line('''  declare Msg="Directory '$1' already exists, skipping creation."''')
        self.line('  boNodeIsDirectory "$1" && boLogDebug "$Msg"                            && return $?')
        self.line('''  Msg="Unable to create directory '$1', failed!"''')
        self.line('  mkdir -p "$1"           || boAbort "$FUNCNAME" "$LINENO" $? 100 "$Msg" || return $?')
        self.line('  boDirectoryRequire "$1" || boAbort "$FUNCNAME" "$LINENO" $? 100 "$Msg" || return $?')
        self.line('} && export -f boDirectoryCreate')
        self.line()
        self.line('boDirectoryRequire () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('  # Require directory $1, abort if it is missing')
        self.line('  boArgsRequire "$FUNCNAME" "$LINENO" $# 1 || return $?')
        self.line('  # $1 = pathname of required directory')
        self.line('  boNodeIsDirectory "$1" && return $?')
        self.line('''  Msg="Directory '$1' is required but is missing!"''')
        self.line('  boNodeExists "$1" || boAbort "$FUNCNAME" "$LINENO" $? 100 "$Msg" || return $?')
        self.line('''  Msg="Directory '$1' is required but is blocked by a non-directory!"''')
        self.line('  boAbort "$FUNCNAME" "$LINENO" 100 100 "$Msg" || return $?')
        self.line('} && export -f boDirectoryRequire')
        self.line()
        self.line('boFileRequire () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('  # Require that file $1 exists, abort if it is missing')
        self.line('  # TODO: Should we check other characteristics like readability or executability?')
        self.line('  boArgsRequire "$FUNCNAME" "$LINENO" $# 1 || return $?')
        self.line('  # $1 = required script file pathname')
        self.line('''  declare -r Msg="File '$1' is required but missing!"''')
        self.line('  boNodeIsFile "$1" || boAbort "$FUNCNAME" "$LINENO" $? 100 "$Msg" || return $?')
        self.line('} && export -f boFileRequire')
        self.line()
        self.line('boScriptRequire () {')
        self.line('  # Require that script file $1 exists, abort if it is missing')
        self.line('  # TODO: Should we check other characteristics like readability or executability?')
        self.line('  boFileRequire "$1" || boFailed "$FUNCNAME" "$LINENO" $? || return $?')
        self.line('} && export -f boScriptRequire')
        self.line()
        self.line('boVariableRequire () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('  # Require environment variable $1, abort if it is missing')
        self.line('  boArgsRequire "$FUNCNAME" "$LINENO" $# 1 || return $?')
        self.line('  # $1 = name of required environment variable')
        self.line('''  declare -r Msg="Variable '$1' is required but is undefined or empty!"''')
        self.line('  ! boVariableIsMissing "$1" || boAbort "$FUNCNAME" "$LINENO" $? 100 "$Msg" || return $?')
        self.line('} && export -f boVariableRequire')
        self.line()
        self.rule()
        self.comment('Functions in this section should NOT call functions from following sections')
        self.line()
        self.line('boExecute () {')
        self.line('  boTraceEntry "$FUNCNAME" "$LINENO" $# "$*"')
        self.line('  # Execute command $1; if it fails, abort with message $2')
        self.line('  boArgsRequire "$FUNCNAME" "$LINENO" $# 2 || return $?')
        self.line('  # $1 = command to execute')
        self.line('  # $2 = message for abort upon failure')
        self.line('  boLogDebug "Executing command: $1"')
        self.line('  $1 || boAbort "$FUNCNAME" "$LINENO" $? $? "$2" || return $?')
        self.line('} && export -f boExecute')
        self.line()
        self.rule()
        self.comment("Successfully 'return', but do NOT 'exit'")
        self.line('return 0')
        self.add_disabled_content_footer()


VISITOR_MAP = VisitorMap(parent_map=script_bash.VISITOR_MAP)


def build():
    script = Script()
    script.generate()
    return script
    
def render(target_directory, target_file):
    script_bash.render(build(), VISITOR_MAP, target_directory, target_file)


""" Disabled content
"""

